package com.typesafe.sbtrc.io

import java.io.File
import sbt.IO

object FileHasher {

  def sha512(file: File): String = {
    val md = java.security.MessageDigest.getInstance("SHA-512")
    val in = new java.io.FileInputStream(file);
    val buffer = new Array[Byte](8192)
    try {
      def read(): Unit = in.read(buffer) match {
        case x if x <= 0 => ()
        case size => md.update(buffer, 0, size); read()
      }
      read()
    } finally in.close()
    // Now migrate to a string we can compare
    digestToHexString(md.digest)
  }

  def digestToHexString(bytes: Array[Byte]): String = {
    val buf = new StringBuffer
    // TODO - error handling necessary?
    def byteToHex(b: Int) = HEX_CHARS(b)
    for (i <- 0 until bytes.length) {
      val b = bytes(i)
      buf append byteToHex((b >>> 4) & 0x0F)
      buf append byteToHex(b & 0x0F)
    }
    buf.toString
  }
  private val HEX_CHARS = "0123456789abcdef".toCharArray
}

class ShimWriter(val name: String, version: String) {

  private val sbtContents = """
// Note: This file is autogenerated by Builder.  Please do not modify!
// Full resolvers can be removed in sbt 0.13
fullResolvers <<= (fullResolvers, bootResolvers) map {
  case (rs, Some(boot)) if !(rs exists (_.name == "activator-local")) =>
    // Add just builder-local repo (as first checked)
    val localRepos = boot filter (_.name == "activator-local")
    localRepos ++ rs
  case (rs, _) => rs
}

// shim plugins are needed when plugins are not "UI aware"
// (we need an interface for the UI program rather than an interface
// for a person at a command line).
// In future plans, we want plugins to have a built-in ability to be
// remote-controlled by a UI and then we would drop the shims.
addSbtPlugin("com.typesafe.sbtrc" % "sbt-shim-""" + name + """" % """" + version + "\")\n"

  // TODO - We'd like to remove the activator name here, but we'd have to clean up the existing shims first...
  private val SHIM_FILE_NAME = "activator-" + name + "-shim.sbt"

  private lazy val pluginSbtFile = {
    val tmp = java.io.File.createTempFile(name, "sbt-shim")
    IO.write(tmp, sbtContents)
    tmp.deleteOnExit()
    tmp
  }

  private lazy val sbtFileSha = FileHasher.sha512(pluginSbtFile)

  private def makeTarget(basedir: File): File =
    new File(new File(basedir, "project"), SHIM_FILE_NAME)

  // update the shim file ONLY if it already exists. Returns true if it makes a change.
  def updateIfExists(basedir: File): Boolean = {
    val target = makeTarget(basedir)
    if (target.exists && FileHasher.sha512(target) != sbtFileSha) {
      IO.copyFile(pluginSbtFile, target)
      true
    } else {
      false
    }
  }

  // update the shim file EVEN IF it doesn't exist. Returns true if it makes a change.
  def ensureExists(basedir: File): Boolean = {
    val target = makeTarget(basedir)
    if (target.exists && FileHasher.sha512(target) == sbtFileSha) {
      false
    } else {
      IO.copyFile(pluginSbtFile, target)
      true
    }
  }
}

object ShimWriter {
  val alwaysIncludedShims = Set("eclipse", "idea", "defaults")
  val knownShims = Set("play") ++ alwaysIncludedShims
}
